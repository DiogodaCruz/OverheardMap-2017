{"version":3,"sources":["../bower_components/dragscroll/dragscroll.js","../bower_components/jquery.scrollTo/jquery.scrollTo.js","../assets/scripts/main.js"],"names":["root","factory","define","amd","exports","dragscroll","this","newScrollX","newScrollY","_window","window","_document","document","mousemove","mouseup","mousedown","EventListener","addEventListener","removeEventListener","dragged","reset","i","el","length","container","md","mu","mm","slice","call","getElementsByClassName","lastClientX","lastClientY","pushed","scroller","cont","e","hasAttribute","elementFromPoint","pageX","pageY","clientX","clientY","preventDefault","scrollLeft","scrollTop","body","documentElement","readyState","module","require","jQuery","$","isWin","elem","nodeName","inArray","toLowerCase","both","val","isFunction","isPlainObject","top","left","$scrollTo","scrollTo","target","duration","settings","defaults","axis","limit","fn","onAfter","extend","queue","offset","over","each","animate","callback","opts","complete","targ","$elem","attr","toff","win","contentWindow","test","is","style","split","Pos","pos","key","prev","max","margin","parseInt","css","parseFloat","Math","min","onAfterFirst","Dim","scroll","size","doc","ownerDocument","html","Tween","propHooks","get","t","prop","set","curr","options","interrupt","_last","stop","next","round","now","ready","width","height","click","event","console","log"],"mappings":"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","file":"main.js","sourcesContent":["/**\n * @fileoverview dragscroll - scroll area by dragging\n * @version 0.0.8\n * \n * @license MIT, see http://github.com/asvd/dragscroll\n * @copyright 2015 asvd <heliosframework@gmail.com> \n */\n\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.dragscroll = {}));\n    }\n}(this, function (exports) {\n    var _window = window;\n    var _document = document;\n    var mousemove = 'mousemove';\n    var mouseup = 'mouseup';\n    var mousedown = 'mousedown';\n    var EventListener = 'EventListener';\n    var addEventListener = 'add'+EventListener;\n    var removeEventListener = 'remove'+EventListener;\n    var newScrollX, newScrollY;\n\n    var dragged = [];\n    var reset = function(i, el) {\n        for (i = 0; i < dragged.length;) {\n            el = dragged[i++];\n            el = el.container || el;\n            el[removeEventListener](mousedown, el.md, 0);\n            _window[removeEventListener](mouseup, el.mu, 0);\n            _window[removeEventListener](mousemove, el.mm, 0);\n        }\n\n        // cloning into array since HTMLCollection is updated dynamically\n        dragged = [].slice.call(_document.getElementsByClassName('dragscroll'));\n        for (i = 0; i < dragged.length;) {\n            (function(el, lastClientX, lastClientY, pushed, scroller, cont){\n                (cont = el.container || el)[addEventListener](\n                    mousedown,\n                    cont.md = function(e) {\n                        if (!el.hasAttribute('nochilddrag') ||\n                            _document.elementFromPoint(\n                                e.pageX, e.pageY\n                            ) == cont\n                        ) {\n                            pushed = 1;\n                            lastClientX = e.clientX;\n                            lastClientY = e.clientY;\n\n                            e.preventDefault();\n                        }\n                    }, 0\n                );\n\n                _window[addEventListener](\n                    mouseup, cont.mu = function() {pushed = 0;}, 0\n                );\n\n                _window[addEventListener](\n                    mousemove,\n                    cont.mm = function(e) {\n                        if (pushed) {\n                            (scroller = el.scroller||el).scrollLeft -=\n                                newScrollX = (- lastClientX + (lastClientX=e.clientX));\n                            scroller.scrollTop -=\n                                newScrollY = (- lastClientY + (lastClientY=e.clientY));\n                            if (el == _document.body) {\n                                (scroller = _document.documentElement).scrollLeft -= newScrollX;\n                                scroller.scrollTop -= newScrollY;\n                            }\n                        }\n                    }, 0\n                );\n             })(dragged[i++]);\n        }\n    }\n\n      \n    if (_document.readyState == 'complete') {\n        reset();\n    } else {\n        _window[addEventListener]('load', reset, 0);\n    }\n\n    exports.reset = reset;\n}));\n\n","/*!\n * jQuery.scrollTo\n * Copyright (c) 2007-2015 Ariel Flesler - aflesler<a>gmail<d>com | http://flesler.blogspot.com\n * Licensed under MIT\n * http://flesler.blogspot.com/2007/10/jqueryscrollto.html\n * @projectDescription Lightweight, cross-browser and highly customizable animated scrolling with jQuery\n * @author Ariel Flesler\n * @version 2.1.2\n */\n;(function(factory) {\n\t'use strict';\n\tif (typeof define === 'function' && define.amd) {\n\t\t// AMD\n\t\tdefine(['jquery'], factory);\n\t} else if (typeof module !== 'undefined' && module.exports) {\n\t\t// CommonJS\n\t\tmodule.exports = factory(require('jquery'));\n\t} else {\n\t\t// Global\n\t\tfactory(jQuery);\n\t}\n})(function($) {\n\t'use strict';\n\n\tvar $scrollTo = $.scrollTo = function(target, duration, settings) {\n\t\treturn $(window).scrollTo(target, duration, settings);\n\t};\n\n\t$scrollTo.defaults = {\n\t\taxis:'xy',\n\t\tduration: 0,\n\t\tlimit:true\n\t};\n\n\tfunction isWin(elem) {\n\t\treturn !elem.nodeName ||\n\t\t\t$.inArray(elem.nodeName.toLowerCase(), ['iframe','#document','html','body']) !== -1;\n\t}\t\t\n\n\t$.fn.scrollTo = function(target, duration, settings) {\n\t\tif (typeof duration === 'object') {\n\t\t\tsettings = duration;\n\t\t\tduration = 0;\n\t\t}\n\t\tif (typeof settings === 'function') {\n\t\t\tsettings = { onAfter:settings };\n\t\t}\n\t\tif (target === 'max') {\n\t\t\ttarget = 9e9;\n\t\t}\n\n\t\tsettings = $.extend({}, $scrollTo.defaults, settings);\n\t\t// Speed is still recognized for backwards compatibility\n\t\tduration = duration || settings.duration;\n\t\t// Make sure the settings are given right\n\t\tvar queue = settings.queue && settings.axis.length > 1;\n\t\tif (queue) {\n\t\t\t// Let's keep the overall duration\n\t\t\tduration /= 2;\n\t\t}\n\t\tsettings.offset = both(settings.offset);\n\t\tsettings.over = both(settings.over);\n\n\t\treturn this.each(function() {\n\t\t\t// Null target yields nothing, just like jQuery does\n\t\t\tif (target === null) return;\n\n\t\t\tvar win = isWin(this),\n\t\t\t\telem = win ? this.contentWindow || window : this,\n\t\t\t\t$elem = $(elem),\n\t\t\t\ttarg = target, \n\t\t\t\tattr = {},\n\t\t\t\ttoff;\n\n\t\t\tswitch (typeof targ) {\n\t\t\t\t// A number will pass the regex\n\t\t\t\tcase 'number':\n\t\t\t\tcase 'string':\n\t\t\t\t\tif (/^([+-]=?)?\\d+(\\.\\d+)?(px|%)?$/.test(targ)) {\n\t\t\t\t\t\ttarg = both(targ);\n\t\t\t\t\t\t// We are done\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// Relative/Absolute selector\n\t\t\t\t\ttarg = win ? $(targ) : $(targ, elem);\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase 'object':\n\t\t\t\t\tif (targ.length === 0) return;\n\t\t\t\t\t// DOMElement / jQuery\n\t\t\t\t\tif (targ.is || targ.style) {\n\t\t\t\t\t\t// Get the real position of the target\n\t\t\t\t\t\ttoff = (targ = $(targ)).offset();\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar offset = $.isFunction(settings.offset) && settings.offset(elem, targ) || settings.offset;\n\n\t\t\t$.each(settings.axis.split(''), function(i, axis) {\n\t\t\t\tvar Pos\t= axis === 'x' ? 'Left' : 'Top',\n\t\t\t\t\tpos = Pos.toLowerCase(),\n\t\t\t\t\tkey = 'scroll' + Pos,\n\t\t\t\t\tprev = $elem[key](),\n\t\t\t\t\tmax = $scrollTo.max(elem, axis);\n\n\t\t\t\tif (toff) {// jQuery / DOMElement\n\t\t\t\t\tattr[key] = toff[pos] + (win ? 0 : prev - $elem.offset()[pos]);\n\n\t\t\t\t\t// If it's a dom element, reduce the margin\n\t\t\t\t\tif (settings.margin) {\n\t\t\t\t\t\tattr[key] -= parseInt(targ.css('margin'+Pos), 10) || 0;\n\t\t\t\t\t\tattr[key] -= parseInt(targ.css('border'+Pos+'Width'), 10) || 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tattr[key] += offset[pos] || 0;\n\n\t\t\t\t\tif (settings.over[pos]) {\n\t\t\t\t\t\t// Scroll to a fraction of its width/height\n\t\t\t\t\t\tattr[key] += targ[axis === 'x'?'width':'height']() * settings.over[pos];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar val = targ[pos];\n\t\t\t\t\t// Handle percentage values\n\t\t\t\t\tattr[key] = val.slice && val.slice(-1) === '%' ?\n\t\t\t\t\t\tparseFloat(val) / 100 * max\n\t\t\t\t\t\t: val;\n\t\t\t\t}\n\n\t\t\t\t// Number or 'number'\n\t\t\t\tif (settings.limit && /^\\d+$/.test(attr[key])) {\n\t\t\t\t\t// Check the limits\n\t\t\t\t\tattr[key] = attr[key] <= 0 ? 0 : Math.min(attr[key], max);\n\t\t\t\t}\n\n\t\t\t\t// Don't waste time animating, if there's no need.\n\t\t\t\tif (!i && settings.axis.length > 1) {\n\t\t\t\t\tif (prev === attr[key]) {\n\t\t\t\t\t\t// No animation needed\n\t\t\t\t\t\tattr = {};\n\t\t\t\t\t} else if (queue) {\n\t\t\t\t\t\t// Intermediate animation\n\t\t\t\t\t\tanimate(settings.onAfterFirst);\n\t\t\t\t\t\t// Don't animate this axis again in the next iteration.\n\t\t\t\t\t\tattr = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tanimate(settings.onAfter);\n\n\t\t\tfunction animate(callback) {\n\t\t\t\tvar opts = $.extend({}, settings, {\n\t\t\t\t\t// The queue setting conflicts with animate()\n\t\t\t\t\t// Force it to always be true\n\t\t\t\t\tqueue: true,\n\t\t\t\t\tduration: duration,\n\t\t\t\t\tcomplete: callback && function() {\n\t\t\t\t\t\tcallback.call(elem, targ, settings);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t$elem.animate(attr, opts);\n\t\t\t}\n\t\t});\n\t};\n\n\t// Max scrolling position, works on quirks mode\n\t// It only fails (not too badly) on IE, quirks mode.\n\t$scrollTo.max = function(elem, axis) {\n\t\tvar Dim = axis === 'x' ? 'Width' : 'Height',\n\t\t\tscroll = 'scroll'+Dim;\n\n\t\tif (!isWin(elem))\n\t\t\treturn elem[scroll] - $(elem)[Dim.toLowerCase()]();\n\n\t\tvar size = 'client' + Dim,\n\t\t\tdoc = elem.ownerDocument || elem.document,\n\t\t\thtml = doc.documentElement,\n\t\t\tbody = doc.body;\n\n\t\treturn Math.max(html[scroll], body[scroll]) - Math.min(html[size], body[size]);\n\t};\n\n\tfunction both(val) {\n\t\treturn $.isFunction(val) || $.isPlainObject(val) ? val : { top:val, left:val };\n\t}\n\n\t// Add special hooks so that window scroll properties can be animated\n\t$.Tween.propHooks.scrollLeft = \n\t$.Tween.propHooks.scrollTop = {\n\t\tget: function(t) {\n\t\t\treturn $(t.elem)[t.prop]();\n\t\t},\n\t\tset: function(t) {\n\t\t\tvar curr = this.get(t);\n\t\t\t// If interrupt is true and user scrolled, stop animating\n\t\t\tif (t.options.interrupt && t._last && t._last !== curr) {\n\t\t\t\treturn $(t.elem).stop();\n\t\t\t}\n\t\t\tvar next = Math.round(t.now);\n\t\t\t// Don't waste CPU\n\t\t\t// Browsers don't render floating point scroll\n\t\t\tif (curr !== next) {\n\t\t\t\t$(t.elem)[t.prop](next);\n\t\t\t\tt._last = this.get(t);\n\t\t\t}\n\t\t}\n\t};\n\n\t// AMD requirement\n\treturn $scrollTo;\n});\n","$(document).ready(function() {\n  var width = $(window).width();\n  var height = $(window).height();\n  $('body').scrollTo('50%', 800);\n\n  $('.centerViewport').click(function(event) {\n    console.log('click');\n    $('body').scrollTo('50%', 800);\n  });\n});\n\n"],"sourceRoot":"assets/scripts/"}